#!/usr/bin/env node
require("babel/register"); // don't put anything above this line!

// parse command line
var nopt = require("nopt")
  , Stream = require("stream").Stream
  , path = require("path")
    , knownOpts = { "phrase" : [String, null]
                , "mem" : Number
                , "time" : Number
                , "cores" : Number
                , "file" : [String, Array]
                , "storm" : Boolean
                , "log" : Boolean
                }
  , shortHands = { "p" : ["--phrase"]
                 , "m" : ["--mem"]
                 , "t" : ["--time"]
                 , "c" : ["--cores"]
                 , "f" : ["--file"]
                 , "s" : ["--storm"]
                 , "l" : ["--log"]
                 }
  , parsed = nopt(knownOpts, shortHands, process.argv, 2)

if(parsed.storm) {
	require("./storm.js")
	process.exit();
}


if(!parsed.file) {
  console.log('Specify file list with -f');
  process.exit();
}

var fs = require('fs')
var model = require('./src/model'),
  Board = model.Board,
  Unit = model.Unit,
  Game = model.Game;
var read = require('./src/reader');
var pathfind = require('./src/pathfind');

var answer = [];

parsed.file.forEach(function(fileName, i, arr) {
	data = fs.readFileSync(fileName);  
  task = JSON.parse(data);

  var game = read(task);
  var initialBoardCells = JSON.parse(JSON.stringify(game.board.cells));
  //console.log(task.units.length);

  var encoding = {
          W : "p",
          E : "b",
          SW : "a",
          SE : "m"
        };

  task.sourceSeeds.forEach(function(seed, i, arr) {
    var solution = "";
    game.board.cells = JSON.parse(JSON.stringify(initialBoardCells));
    var rand = game.board.getRandomGenerator(seed);

    for(var unitIndex = 0; unitIndex < task.sourceLength; unitIndex++) {
      var currentUnit = rand()%task.units.length;  
      //console.log(currentUnit);

      var unit = new Unit(task.units[currentUnit].pivot, task.units[currentUnit].members);
      //console.log(unit);
      game.unit = game.spawn(game.board, unit);    

      if(parsed.log) {
        game.display();
        console.log(" ");
      }



      // check for endgame
      if(!game.isValidPosition(game.board, game.unit))
        break;

      // TODO: solve problem here

      var unitDest = game.findUnitTargetPlacement(game.board, game.unit);

      while(1) {

        // using pathfinder
        var tmp = game.unit;
        game.unit = unitDest;
        if(parsed.log) {
          game.display();
          console.log("===");
        }
        game.unit = tmp;

        var path = pathfind(game.board, game.unit, game.unit.pivot, unitDest.pivot);

        if(parsed.log) {
          console.log(path.commands);
        }

        if(path.status == 'success')
          break;

        unitDest = game.findNextTargetPlacement(game.board, unitDest);
      }

      for(var i=0; i < path.commands.length; i++) {

        var dir = path.commands[i];

        if(parsed.log) { 
          console.log(" i=" + i + " of "+path.commands.length);
          console.log(dir);
        }

        var moved = game.unit.move(dir);
        solution += encoding[dir];
        if(game.isValidPosition(game.board, moved)) {
          game.unit = moved;
          solution += encoding[dir];

          if(parsed.log) {
            game.display();
            console.log("valid ");
          }
        }
        else {
          if(parsed.log) {
            game.display();
            console.log("invalid ");
          }
          break;
        }
      }

/*
      path.commands.forEach(function(c) {
        solution += encoding[c];    
      });      
*/
      solution += ' ';

      //game.unit = unitDest;
      if(parsed.log) {
        game.display();
        console.log("!!!!");
      }

/*
      var tmp = game.unit;
      game.unit = unitDest;
      if(parsed.log) {
        game.display();
        console.log("===");
      }
      game.unit = tmp;

      while(1) {

        var dir = game.unit.pivot.x >= unitDest.pivot.x ? "W" : "E";
        if(Math.abs(game.unit.pivot.x - unitDest.pivot.x) <=1)
          dir = "S" + dir;
        
        if(parsed.log) { 
          console.log(" game.unit.pivot.x=" + game.unit.pivot.x + " unitDest.pivot.x="+unitDest.pivot.x);
          console.log(dir);
        }

        var moved = game.unit.move(dir);
        solution += encoding[dir];
        if(game.isValidPosition(game.board, moved)) {
          game.unit = moved;
          if(parsed.log) {
            game.display();
            console.log(" ");
          }
        }
        else
          break;
      }
*/

      /*
      while(1) {

        var dir = (iteration++)%2;


        var moved = game.unit.move(dir ? "SW" : "SE");
        solution += dir ? 'a' : 'm';
        if(game.isValidPosition(game.board, moved)) {
          game.unit = moved;
          if(parsed.log) {
            game.display();
            console.log(" ");
          }
        }
        else
          break;
      }*/
      game.board.fillByUnit(game.unit);
      game.board.clearLines();

      game.unit = undefined;
      
      if(parsed.log) {
        //game.display();
        //console.log(" ");
        console.log("------------");
      }
    }

    var entry = {
      problemId : task.id,
      seed : seed,
      tag : 'cw_v1_pathfind' + task.id,
      solution : solution
    };  
    answer.push(entry);

  });  
});

console.log(JSON.stringify(answer));