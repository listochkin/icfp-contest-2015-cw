#!/usr/bin/env node
require("babel/register"); // don't put anything above this line!

// parse command line
var nopt = require("nopt")
  , Stream = require("stream").Stream
  , path = require("path")
  , knownOpts = { "phrase" : [String, null]
                , "mem" : Number
                , "time" : Number
                , "cores" : Number
                , "file" : [String, Array]
                , "storm" : Boolean
                , "log" : Boolean
                , "perflog" : Boolean
                , "depth" : Number // how deep to look for potential target unit positions
                , "improve" : Boolean
                , "suppress" : Boolean // suppress output of problem answer
                }
  , shortHands = { "p" : ["--phrase"]
                 , "m" : ["--mem"]
                 , "t" : ["--time"]
                 , "c" : ["--cores"]
                 , "f" : ["--file"]
                 , "s" : ["--storm"]
                 , "l" : ["--log"]
                 , "i" : ["--improve"]
                 , "e" : ["--perflog"]
                 , "d" : ["--depth"]
                 , "s" : ["--suppress"]
                 }
  , parsed = nopt(knownOpts, shortHands, process.argv, 2)

if(parsed.storm) {
	require("./storm.js")
	process.exit();
}

if(parsed.improve) {
  require("./improver.js")
  process.exit();
}

var fs = require('fs')
var model = require('./src/model'),
  Board = model.Board,
  Unit = model.Unit,
  Game = model.Game,
  TargetPlacementGenerator = model.TargetPlacementGenerator;

var read = require('./src/reader');
var pathfind = require('./src/pathfind');

var answer = [];
var seedScores = [];

if(!parsed.file) {
  console.log('Specify file list with -f');
  process.exit();
}

var lookupDepth = 1;
if (parsed.depth) {
  lookupDepth = parsed.depth;
}

var startTime = new Date();

parsed.file.forEach(function(fileName, i, arr) {
	data = fs.readFileSync(fileName);
  task = JSON.parse(data);

  var game = read(task);
  var initialBoardCells = JSON.parse(JSON.stringify(game.board.cells));
  //console.log(task.units.length);

  var encoding = {
          W : "p",
          E : "b",
          SW : "a",
          SE : "m",
          CW : "d",
          CCW : "k"
        };

  task.sourceSeeds.forEach(function(seed, i, arr) {
      var solution = "";
      game.board.cells = JSON.parse(JSON.stringify(initialBoardCells));
      game.clearScore();
      var rand = game.board.getRandomGenerator(seed);

      for(var unitIndex = 0; unitIndex < task.sourceLength; unitIndex++) {
        var currentUnit = rand()%task.units.length;
        //console.log(currentUnit);

        var unit = new Unit(task.units[currentUnit].pivot, task.units[currentUnit].members);
        game.unit = game.spawn(game.board, unit);

        if(parsed.log) {
          game.display();
          console.log(" ");
        }

        // check for endgame
        if(!game.isValidPosition(game.board, game.unit))
          break;

        // Find best reachable position and path there
        var targetGenerator = new TargetPlacementGenerator(game.board, game.unit, lookupDepth);
        var unitDest = targetGenerator.next();
        if(!unitDest) {
          solution += 'a';
          break;
        }
        var generatorFailed = false;
        while(!generatorFailed) {
          // using pathfinder

           if(parsed.log) {
             var tmp = game.unit;
             game.unit = unitDest;
             game.display();
             console.log("placement found");
             game.unit = tmp;
           }

          var path = pathfind(game.board, game.unit, game.unit.pivot, unitDest.pivot);
          // if(parsed.log) {
          //   console.log(path.commands);
          // }
          if(path.status == 'success')
            break;

          unitDest = targetGenerator.next();
          if(!unitDest) {
            solution += 'a';
            generatorFailed = true;
          }
        }

        // safe-trace returned path and generate answer sequence
        var failed = false;
        for(var i=0; i < path.commands.length; i++) {
          var dir = path.commands[i];

          //if(parsed.log) {
          //  console.log(" i=" + i + " of "+path.commands.length);
          //  console.log(dir);
          //}
          solution += encoding[dir];
          var moved = game.unit.move(dir);
          if(game.isValidPosition(game.board, moved)) {
            game.unit = moved;

            // if(parsed.log) {
            //   game.display();
            //   console.log("valid move ");
            // }
          }
          else {
            failed = true;
             if(parsed.log) {
               game.display();
               console.log("invalid move ");
             }
            break;
          }
        }

        // finish path to locking
        if(!failed) {
          while(1) {
            var dir = "E";            
            var moved = game.unit.move(dir);
            solution += encoding[dir];
            if(game.isValidPosition(game.board, moved)) {
              game.unit = moved;              
            }
            else
              break;
          }
        }

        if(parsed.log) {
           game.display();
           console.log(solution);
         }
         //solution += ' ';

        // apply unit and find score
        game.board.fillByUnit(game.unit);
        game.moveScoreCount(game);
        if(parsed.log) {
          console.log('Score so far: ', game.moveScoreGet());
        }
        game.board.clearLines();
        game.unit = undefined;

        if(parsed.log) {
          //game.display();
          //console.log(" ");
          console.log("unit completed");
        }
      }

    var t9 = require('./src/t9');
    var t9solution = t9(solution);

    //solution = solution.substring(0, solution.length-1);
    var entry = {
      problemId : task.id,
      seed : seed,
      tag : 'cw_v14_pathfind' + task.id,
      solution : t9solution
    };
    answer.push(entry);

    seedScores.push(game.moveScoreGet().move_scores);

  });
});

var executionTime = new Date() - startTime;

if (!parsed.suppress)
  console.log(JSON.stringify(answer));

if (parsed.perflog) {
  var sum = 0;
  for( var i = 0; i < seedScores.length; i++ ){
      sum += seedScores[i];
  }
  var avg = sum/seedScores.length;

  console.log('Lookup depth: ' + lookupDepth
    + ', Seed scores: ' + JSON.stringify(seedScores) + " Avg=" + avg
    + ', Execution time sec: ' + (executionTime / 1000));
}
